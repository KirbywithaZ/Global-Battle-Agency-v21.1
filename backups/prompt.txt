I'm making a plugin for Pokemon Essentials that allows for connection to the internet, enabling Online Storage, Online Trading, and Online Battling, as well as other features.

The Plugin is called the Global Battle Agency (v21.1)

The project uses Supabase (https://supabase.com), Cloudflare Workers, Pokemon Essentials and RPGXP.

Currently, I am dealing with the Online Storage portion of it.

The code for Online Storage is this:

#===============================================================================
# Global Battle Agency / Online Trading
#===============================================================================

module GlobalBattleAgency
  API_URL       = "https://global-battle-agency.kirbywithaz.workers.dev"
  
  # --- CONFIGURATION ---
  STUDIO_NAME   = "KirbyWithAz_Games" 
  SHARED_FOLDER = ENV['AppData'] + "/#{STUDIO_NAME}/"
  IDENTITY_FILE = SHARED_FOLDER + "gba_registry.txt"

  #-----------------------------------------------------------------------------
  # Identity Management
  #-----------------------------------------------------------------------------
  
  def self.get_master_key
    return "#{$player.name}_#{$player.id}"
  end

  # Stores the current game's identity into a shared local map
  def self.save_identity_locally
    begin
      Dir.mkdir(SHARED_FOLDER) if !File.exists?(SHARED_FOLDER)
      
      registry = {}
      if File.exists?(IDENTITY_FILE)
        begin
          # Note: eval is used here to parse the Ruby Hash string
          registry = eval(File.read(IDENTITY_FILE))
        rescue
          registry = {}
        end
      end

      # Logs the ID under the specific game title from Game.ini
      registry[System.game_title] = self.get_master_key
      
      File.open(IDENTITY_FILE, "w") { |f| f.write(registry.inspect) }
      echoln "GBA: Identity linked locally for #{System.game_title}."
    rescue
      echoln "GBA: Failed to save local identity."
    end
  end

  #-----------------------------------------------------------------------------
  # Storage Functions
  #-----------------------------------------------------------------------------
  
  # Transmits Pokémon to the cloud and removes the instance from the party.
  def self.upload_pokemon(slot = 0)
    pkmn = $player.party[slot]
    return pbMessage(_INTL("No Pokemon found in slot {1}!", slot + 1)) if !pkmn
    return pbMessage(_INTL("You can't deposit your last Pokemon!")) if $player.party.length <= 1

    # Serialize and encode the Pokémon object
    pokemon_dna = [Marshal.dump(pkmn)].pack("m0")
    payload = { "id" => self.get_master_key, "data" => pokemon_dna }

    pbMessage(_INTL("Sending {1} to the GBA cloud...", pkmn.name))

    begin
      response = HTTPLite.post("#{API_URL}/save", payload)
      if response[:body] && response[:body].include?("OK")
        $player.party.delete_at(slot)
        
        # Automatically update registry on success.
        self.save_identity_locally 
        
        pbMessage(_INTL("Success! {1} has been moved to the cloud.", pkmn.name))
      else
        pbMessage(_INTL("The cloud is full! Try again later."))
      end
    rescue Exception => e
      echoln "GBA Error: #{e.message}"
      pbMessage(_INTL("Failed to connect to the GBA cloud."))
    end
  end

  # Retrieves Pokémon from the cloud and removes the cloud instance.
  def self.download_pokemon
    if $player.party_full?
      return pbMessage(_INTL("Your party is full! Make some room first."))
    end
    
    pbMessage(_INTL("Accessing the GBA cloud..."))
    id = self.get_master_key
    self.fetch_and_load(id)
  end

  #-----------------------------------------------------------------------------
  # Reunion System
  #-----------------------------------------------------------------------------

  # Scans and imports Pokémon from other games recorded in the studio folder.
  def self.auto_invite_legacy
    if $player.party_full?
      return pbMessage(_INTL("Your party is full!"))
    end

    if File.exists?(IDENTITY_FILE)
      begin
        registry = eval(File.read(IDENTITY_FILE))
        
        # Excludes the current game from the selection list.
        registry.delete(System.game_title)

        if registry.empty?
          return pbMessage(_INTL("No other local game records were found."))
        end

        commands = registry.keys
        choice = pbMessage(_INTL("Past journeys detected! Which record should be accessed?"), commands, -1)
        
        if choice >= 0
          target_game = commands[choice]
          legacy_id = registry[target_game]
          pbMessage(_INTL("Accessing the cloud for {1}...", target_game))
          self.fetch_and_load(legacy_id)
        end
      rescue Exception => e
        echoln "GBA Reunion Error: #{e.message}"
        pbMessage(_INTL("The identity registry is corrupted."))
      end
    else
      pbMessage(_INTL("No records of a past journey found on this device."))
    end
  end

  # Processes the communication with the server to retrieve and load data.
  def self.fetch_and_load(target_id)
    begin
      response = HTTPLite.get("#{API_URL}/get?id=#{target_id}")
      data = response[:body]

      if data && data != "NOT_FOUND" && !data.include?("Error")
        decoded_data = data.unpack("m0")[0]
        pkmn = Marshal.load(decoded_data)
        $player.party.push(pkmn)
        
        # Deletes the cloud entry after a successful transfer to prevent cloning.
        HTTPLite.get("#{API_URL}/delete?id=#{target_id}")
        
        pbMessage(_INTL("Welcome back, {1}!", pkmn.name))
      else
        pbMessage(_INTL("No Pokemon were found in that cloud locker."))
      end
    rescue Exception => e
      echoln "GBA Error: #{e.message}"
      pbMessage(_INTL("Connection failed! Check your internet."))
    end
  end
end

--------------------------------

and the Cloudflare Workers code is this:

export default {
  async fetch(request, env) {
    const url = new URL(request.url);
    const SUPABASE_URL = env.SUPABASE_URL;
    const SUPABASE_KEY = env.SUPABASE_KEY;

    const corsHeaders = {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
      "Access-Control-Allow-Headers": "*",
    };

    if (request.method === "OPTIONS") {
      return new Response(null, { headers: corsHeaders });
    }

    // --- STATISTICS: Count total Pokémon entries ---
    if (url.pathname.includes("stats")) {
      const response = await fetch(`${SUPABASE_URL}/rest/v1/gba_storage?select=id`, {
        method: "HEAD",
        headers: {
          "apikey": SUPABASE_KEY,
          "Authorization": `Bearer ${SUPABASE_KEY}`,
          "Prefer": "count=exact"
        }
      });
      const count = response.headers.get("Content-Range")?.split("/")[1] || "0";
      return new Response(count, { headers: corsHeaders });
    }

    // --- DEPOSIT: Save serialized data to Supabase ---
    if (url.pathname.includes("save")) {
      const bodyText = await request.text();
      const params = new URLSearchParams(bodyText);
      const id = params.get("id");
      const data = params.get("data");

      await fetch(`${SUPABASE_URL}/rest/v1/gba_storage`, {
        method: "POST",
        headers: {
          "apikey": SUPABASE_KEY,
          "Authorization": `Bearer ${SUPABASE_KEY}`,
          "Content-Type": "application/json",
          "Prefer": "resolution=merge-upsert"
        },
        body: JSON.stringify({ id: id, data: data })
      });

      return new Response("OK", { headers: corsHeaders });
    }

    // --- WITHDRAW: Retrieve data from Supabase ---
    if (url.pathname.includes("get")) {
      const id = url.searchParams.get("id");
      const response = await fetch(`${SUPABASE_URL}/rest/v1/gba_storage?id=eq.${id}&select=data`, {
        headers: {
          "apikey": SUPABASE_KEY,
          "Authorization": `Bearer ${SUPABASE_KEY}`
        }
      });
      const result = await response.json();
      const data = result.length > 0 ? result[0].data : "NOT_FOUND";
      return new Response(data, { headers: corsHeaders });
    }

    // --- DELETE: Remove entry (Anti-Cloning) ---
    if (url.pathname.includes("delete")) {
      const id = url.searchParams.get("id");
      
      // Preserve Mystery Gifts for multiple claims
      if (id && id.startsWith("GIFT_")) {
        return new Response("GIFT_RETAINED", { headers: corsHeaders });
      }

      await fetch(`${SUPABASE_URL}/rest/v1/gba_storage?id=eq.${id}`, {
        method: "DELETE",
        headers: {
          "apikey": SUPABASE_KEY,
          "Authorization": `Bearer ${SUPABASE_KEY}`
        }
      });
      return new Response("DELETED", { headers: corsHeaders });
    }

    return new Response("GWelcome... to the Global Battle Agency!", { headers: corsHeaders });
  }
};


Tell me what you understand the code does, and what it actually does.
